*《第一行代码》*
================

## 1 开始启程--你的第一行Android代码

- Android系统架构
    - Linux Kernal
    - libraries & Android Runtime
    - Application Framework
    - Application

`Android 5.0`使用ART替换Dalvik

- 四大组件
    - Activity
    - Service
    - Broadcast Receiver
    - Content Provider

```
Android项目结构


project
├── app/
│   ├── build/
│   ├── libs/  # 被添加到构建路径中的第三方jar包
│   └── src/
│        ├─── main/
│        │     ├──── cpp/
│        │     ├──── java/
│        │     ├──── res/  # 图片/布局/字符串等资源
│        │     └──── AndroidManifest.xml  # 整个Android项目的配置文件
│        ├─── build.gradle  # app模块的gradle构建脚本
│        └─── proguard-rules.pro  # 项目的代码混淆规则
├── gradle/  # 包含下载的gradle wrapper及配置文件
├── build.gradle  # 全局gradle构建脚本
├── gradle.properties  # 全局gradle配置文件
├── gradlew / gradlew.bat  # gradle命令
├── settings.gradle  # 指定项目引入的模块
└── local.properties  # 本地Android SDK path
```

- res资源引用
    - res/values/strings.xml
    - CODE: R.string.app_name
    - XML: @string/app_name

- build.gradle

- logcat

## 2 先从看得到的入手--探究活动

### 2.2 活动的基本用法

- XML
    - 定义id: android:id="@+id/sample_text"
    - 使用id: @string/app_name

- activity都需要重新onCreate
- 加载布局: setContentView
- AndroidManifest.xml中注册activity
    - 首先启动的activity
        - <action android:name="android.intent.action.MAIN" />
        - <category android:name="android.intent.category.LAUNCHER" />
- menu
- activity.finish()

### 2.3 使用Intent在活动之间穿梭

- Intent
    - 执行动作
    - 传递数据

- 显式Intent
    - 指明NActivity.class
- 隐式Intent
    - action
    - category
        - new Intent: 默认 android.intent.category.DEFAULT
        - Manifest中需要指定category,否则无法响应android.intent.category.DEFAULT
    - data: setData
    - 同时匹配才能响应
    - Intent: 1 action, 1+ category
- Intent传递数据
    - putExtra
    - getIntent(), getXXXExtra
    - startActivityForResult(intent, requestCode): 传递数据到上一个Activity
        - 新activity中调用setResult(resultCode, intent)
        - 重写onActivityResult(requestCode, resultCode, intent) / onBackPressed

### 2.4 活动的生命周期

- 返回栈
- 活动状态
    - 运行状态: 栈顶
    - 暂停状态: 不在栈顶但可见
    - 停止状态: 不在栈顶且完全不可见
    - 销毁状态: 返回栈中移除
- 活动生存期
    - 完整生存期
    - 可见生存期
    - 前台生存期
    - onCreate: 第一次被创建
    - onStart: 不可见 -> 可见
    - onResume: 运行状态,准备和用户交互
    - onPause: 准备启动或恢复另一活动
    - onStop: 完全不可见
    - onDestroy: 销毁状态之前
    - onRestart: 停止到运行状态前,onStop -> onStart
- 被垃圾回收
    - 回收后back调用onCreate
    - onSaveInstanceState保存数据
    - Bundle可以存放在Intent中

### 2.5 活动的启动模式

- standard
    - 每次创建新实例
- singleTop
    - 栈顶是该活动直接使用
- singleTask
    - 检查返回栈中是否存在实例,存在的话实例上方活动全部出栈
- singleInstance
    - 启用新的返回栈,系统级的activity单例

```
singleTask:
Activity1打开Activity2, Activity2打开Activity1

Activity1: onCreate
Activity1: onStart
Activity1: onResume
Activity1: onPause
Activity2: onCreate
Activity2: onStart
Activity2: onResume
Activity1: onStop
Activity2: onPause
Activity1: onRestart
Activity1: onStart
Activity1: onResume
Activity2: onStop
Activity2: onDestroy
```

### 2.6 活动的最佳实践

- 获取类名
    - instance.getClass().getName()
- onCreate中收集activity
- Intent传递数据时对其进行一层封装以完成对必要项的传入

## 5 全局大喇叭--详解广播机制

### 5.1 广播机制简介

- 标准广播
    - 异步
- 有序广播
    - 优先级

### 5.2 接收系统广播

#### 5.2.1 动态注册

- 启动app后才可以注册

```
// 0. get broadcast manager
localBroadcastManager = LocalBroadcastManager.getInstance(this);

// 1. extends BroadcastReceiver
class LocalReceiver extends BroadcastReceiver {

    @Override
    public void onReceive(Context context, Intent intent) {
        Toast.makeText(context, "received local broadcast", Toast.LENGTH_SHORT).show();
    }

}

// 2. onCreate registerReceiver
intentFilter = new IntentFilter();
intentFilter.addAction("com.example.broadcasttest.LOCAL_BROADCAST");
localReceiver = new LocalReceiver();
localBroadcastManager.registerReceiver(localReceiver, intentFilter); // 注册本地广播监听器

// 3. onDestroy unregisterReceiver
localBroadcastManager.unregisterReceiver(localReceiver);

// 4. AndroidManifest.xml中授权

// 5. send broadcast
Intent intent = new Intent("com.example.broadcasttest.LOCAL_BROADCAST");
localBroadcastManager.sendBroadcast(intent); // 发送本地广播
```

#### 5.2.2 静态注册

- 静态注册
    - Manifest.xml
        - intent
    - permission
    - exported: 是否允许Receiver接收本程序外广播
    - enabled: 是否启动Receiver
- Receiver
    - 不允许开启线程
    - 避免耗时操作

### 5.3 发送自定义广播

- broadcast是跨进程的

#### 5.3.2 发送有序广播

- sendOrderedBroadcast
- Manifest.xml android:priority
- abortBroadcast: 截断广播

### 5.4 使用本地广播

- 只在应用程序内部传递
- 只能动态注册
- 静态注册的broadcast无法弹出UI控件,动态注册的可以
